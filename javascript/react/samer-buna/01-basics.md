# 01 Les basiques

<img src="assets/Screenshot 2020-08-13 at 09.07.14.png" alt="Screenshot 2020-08-13 at 09.07.14" style="zoom:50%;" />

## Avantages

**React** simplifie le `DOM`.

**React** est du pure **Javascript** : L'`API` de **React** est assez petite, le reste c'est du pure **Javascript**.

C'est une **librairie**, pas un **framework** : plus souple, plus petit qu'un **framework**.

**React Native** permet de faire du mobile avec les m√™mes comp√©tences.



## React Fundamental

3 concept

1. Composant
2. Mise √† jour reactive
3. virtual DOM



<img src="assets/Screenshot 2020-08-13 at 10.07.33.png" alt="Screenshot 2020-08-13 at 10.07.33" style="zoom: 33%;" />

## `Props` et `State`

Les `props` sont immuable.

Seul le `state` peut √™tre chang√© dans une application React.



## JSX

**JSX** est un compromis entre le **HTML** et de pure fonction javascript.

**JSX** est compil√© en pure fonction javascript qui √† leur tour vont manipuler le `DOM`.

<img src="assets/Screenshot 2020-08-13 at 10.47.11.png" alt="Screenshot 2020-08-13 at 10.47.11" style="zoom:50%;" />



## Exemple

```jsx
const Count = () => {
  const [count, setCount] =  useState(0);
  return <button onClick={() => setCount(count + 1)}>{ ü¶ã count }</button>
};

ReactDOM.render(<Count />, mountNode);
```

#### ! ne pas passer directement `setCount` √† `onClick` car il serait ex√©cut√© au lieu d'√™tre pass√© au gestionnaire de click.

`ReactDOM.render` est le point d'entr√©e d'une application **React**.

Le premier argument est un √©l√©ment **JSX**, le deuxi√®me est le point de montage dans le `DOM` r√©el.

`mountNode = document.getElementById("mountNode")` 

On peut  r√©√©crire le **JSX** de cette fa√ßon :

```js
return React.createElement("button",{onClick: () => {setCount(count + 1)}},"\uD83E\uDD8B ", count);
```

Le nom d'un composant **doit** commencer par une lettre capitale pour ce diff√©rencier du `html` classique.



### Am√©lioration du style

```jsx
const Count = () => {
  const [count, setCount] =  useState(5);
  const handleClick = () => setCount(count * 2);
  
  return (<button onClick={handleClick}>
            ü¶ã { count }
          </button>);
};
```

Utilisation des parenth√®se en `JSX` pour indenter de mani√®re lisible.

Cr√©ation de `handlClick` pour sortir la logique de la fonction du `JSX`.

## Afficher deux composants

Utilisation d'un tableau de composant :

```jsx
function Count() {
  const [count, setCount] =  useState(5);
  const handleClick = () => setCount(count * 2);
  
  return (<button onClick={handleClick}>
            ü¶ã { count }
          </button>);
}

function Display() {
  return (<div> .... </div>);
}

ReactDOM.render([<Count />, <Display />], mountNode);
```

On peut aussi utiliser une `<div>` pour entourer les deux composants :

```jsx
ReactDOM.render(
	<div>
    	<Count />
        <Display />
    </div>,
    mountNode
)
```

Ou pour ne pas ajouter une `<div>` au `DOM` r√©el on peut utiliser `React.Fragment` :

```jsx
ReactDOM.render(
	<React.Fragment>
    	<Count />
        <Display />
    </React.Fragment>,
    mountNode
)
```

`<React.Fragment>` poss√®de un raccourci en `JSX` : `<>`

```jsx
ReactDOM.render(
	<>
    	<Count />
        <Display />
    </>,
    mountNode
)
```



## Remonter le `state` d'un niveau

Pour que deux composants puissent communiquer, le `state` doit se trouver dans le parent de ces deux composants.

```jsx
function App() {
  const [count, setCount] =  useState(5);
  const incrementCount = () => setCount(count + 1);
  
  return [<h1>My App</h1>,<Count incrementCount={incrementCount} />, <Display message={count} />];
}
```

### One-Way flow of data

On passe les donn√©es par l'objet cl√©-valeur `props` en utilisant la syntaxe des attributs `HTML`.

```jsx
function Display(props) {
  return (<div> {props.message} </div>);
}
```

On peut simplifier la syntaxe :

```jsx
function Display({message}) {
  return (<div> {message} </div>);
}
```

### S√©paration des responsabilit√©s

```jsx
function Button({ onClickFunction }) { 
  
  return (<button onClick={onClickFunction}>
            ü¶ã + 1
          </button>);
}

function Display({message}) {
  return (<div> {message} </div>);
}

function App() {
  const [count, setCount] =  useState(5);
  const incrementCount = () => setCount(count + 1);
  
  return (<div>
            <h1>My App</h1>
            <Button onClickFunction={incrementCount} />
            <Display message={count} />
          </div>);
}

ReactDOM.render(<App />, mountNode);
```

Le composant `App` d√©tient la logique des donn√©es tandis que `Display` et `Button` n'ont pas √† savoir ce qui se cache derri√®re `message` et `onClickFunction`, mais juste afficher et invoquer au click.

Chaque composant √† sa responsabilit√© bien s√©par√©e des autres.

Une question est couramment pos√©e dans **React** :

#### Quel composant a la responsabilit√© du `state` ?

Le plus haut possible dans la hi√©rarchie des composants  et le plus pr√®s possible des composants utilisants les valeurs du `state`.



## Manipulation du `DOM` vs React

```jsx
const render = () => {
    document.getElementById("mountNode").innerHTML = `
    <div>
      Hello HTML
      <input />
      <pre>${new Date().toLocaleTimeString()}</pre>
    </div
  `;
  

  ReactDOM.render(
    React.createElement(
      "div",
      null,
      "Hello React",
      React.createElement(
        "input",
        null
      ),
      React.createElement(
        "pre",
        null,
        new Date().toLocaleTimeString()
      )
    ),
    document.getElementById("mountNode2")
  );
}

setInterval(render, 1000);
```

<img src="assets/Screenshot 2020-08-13 at 15.57.28.png" alt="Screenshot 2020-08-13 at 15.57.28" style="zoom:50%;" />

On voit que le m√™me `HTML` rendu via **React** est plus long √† √©crire qu'avec les manipulations de `DOM` classique.

Mais l√† o√π la magie op√®re c'est que le premier `input` est inutilisable, car il se r√©g√©n√®re toutes les secondes.

Par contre le deuxi√®me `input` g√©rer par **React** est tout √† fait utilisable car **React** ne modifie les noeuds du `DOM` que si leur valeur a chang√©.



<img src="assets/Screenshot 2020-08-13 at 16.03.53.png" alt="Screenshot 2020-08-13 at 16.03.53" style="zoom:50%;" />

On voit dans le premier cas que toutes la chaine du `DOM` est √† chaque `tick` modifier tandis que dans le deuxi√®me cas c'est juste la balise `pre`.

**React** permet de r√©fl√©chir a son interface de mani√®re **d√©clarative** (quoi) et non **imp√©rative** (comment).

cela permet de se concentrer sur la logique m√©tier de son interface sans se perdre en comment mettre √† jour le `DOM`.

Le `Virtual DOM` peut √™tre √©crit en `JSX`, ce qui rend la syntaxe de **React** tr√®s agr√©able.